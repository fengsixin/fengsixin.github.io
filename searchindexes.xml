<?xml version="1.0" encoding="utf-8" standalone="yes"?><search><entry><title>全光网的那些事儿(1)</title><url>/post/20230808-note/</url><categories><category>POL</category></categories><tags><tag>PON</tag></tags><content type="html"> PON(Passive Optical Network)无源光纤网络，是目前接入网的主流解决方案。市场上主要存在EPON，10GEPON，GPON，XG-PON，XGS-PON等标准的PON网络可供选择。
目前在运营商市场，EPON、10GEPON标准主要被电信、联通选用。移动则选择GPON、XG-PON技术方案；在日常商用市场上，则是GPON、XG-PON技术方案占据主流。很少见到EPON设备。
PON网络由三部分组成、分别是光线路终端OLT（Optical Line Terminal）、ODN光分配网（Optical Distribution Network）,光网络单元 ONU（ Optical Network Unit）。
图1 XG-PON网络结构示意图 XG-PON是基于ITU-T G.987的无源光网络接入技术，是由ITU-T G.984（GPON）标准演进而来。而不同PON标准技术区别如下图： 图2 PON标准差异图 好了，本篇结束。</content></entry><entry><title>从合并表获取价格填入广联达表08分表内</title><url>/post/20230807-python/</url><categories><category>python</category></categories><tags><tag>python</tag><tag>便捷工具</tag><tag>广联达</tag></tags><content type="html"><![CDATA[  上一篇把所有广联达表08的分表内容汇总了，然后我挨个填入型号价格以后面临一个巨大问题就是我该怎么填回去。我知道excel有自带的VLOOKUP，但是这么多分表挨个填也使一件十分巨大的工程量。算了，还是问问chaiGPT把。果然又给了我一段代码：
import os import pandas as pd # 读取合并后的文件 merge_file_path = &#39;D:\\fsx\\python\\data\\hebing.xlsx&#39; merge_df = pd.read_excel(merge_file_path, sheet_name=0, header=0) # 遍历D:\fsx\python\data\xt文件夹下的所有子文件夹 root_folder = &#39;D:\\fsx\\python\\data\\xt&#39; for root, dirs, files in os.walk(root_folder): for file in files: # 只处理Excel文件，并且跳过以~$开头的临时文件和合并后的文件 if file.endswith(&#39;.xlsx&#39;) and not file.startswith(&#39;~$&#39;) and os.path.join(root, file) != merge_file_path: # 读取Excel文件 xls = pd.ExcelFile(os.path.join(root, file), engine=&#39;openpyxl&#39;) # 检查文件是否有第二个标签页 if len(xls.sheet_names) &gt; 1: # 读取第二个标签页（索引为1），并指定使用第三行作为列名 df = pd.read_excel(xls, sheet_name=1, header=2) # 将金额列名改为&#39;金额&#39; df.rename(columns={df.columns[7]: &#39;金额&#39;}, inplace=True) # 将合并后的文件与当前文件进行匹配，对应项目名称和项目特征描述相同的物品，将金额信息填回当前文件内 for index, row in merge_df.iterrows(): df.loc[(df[&#39;项目名称&#39;]==row[&#39;项目名称&#39;]) &amp; (df[&#39;项目特征描述&#39;]==row[&#39;项目特征描述&#39;]), &#39;金额&#39;] = row[&#39;金额&#39;] # 将修改后的数据写回当前文件 writer = pd.ExcelWriter(os.path.join(root, file)) df.to_excel(writer, sheet_name=&#39;Sheet2&#39;, index=False) writer._save() 虽然，但是，价格是全部填进去了，但是貌似excel的文件格式都没有了。。。算了总比我自己填要快，源表格复制一份，然后将价格那一列链接到新文件中，over。今天这个费时间点，应该用了2个小时@！@
  ]]></content></entry><entry><title>合并广联达导出表08的python代码</title><url>/post/20230804-python/</url><categories><category>python</category></categories><tags><tag>便捷工具</tag><tag>python</tag></tags><content type="html"><![CDATA[  接到一个项目投标，招标人发出来的表格是广联达导出的excel表格。我一看，好家伙先分四个区域，然后每个区域又有无数个厂房，厂房文件夹下面才有这个区域的广联达表格。
现在我的任务是需要对这些表格内的产品报价。挨个打开填固然是一种办法，但是很容易发生不同表格内的设备价格不一致问题。最好的办法就是先把表格合并，同一种设备的数量累加然后在总表中填写价格，这样就能避免价格不一致问题。
下面是代码，我使用chatgpt生成的，其实不需要懂编程，自己需要干啥告诉它就好：
import pandas as pd import os # 初始化一个空的DataFrame来存储所有的数据 all_data = [] #遍历D:\..\python\data\xt文件夹下的所有子文件夹，改成你的文件地址 for root, dirs, files in os.walk(&#39;D:\\fsx\\python\\data\\xt&#39;): for file in files: #只处理Excel文件，并且跳过以~$开头的临时文件 if (file.endswith(&#39;.xlsx&#39;) or file.endswith(&#39;.xls&#39;)) and not file.startswith(&#39;~$&#39;): # 读取Excel文件 xls = pd.ExcelFile(os.path.join(root, file)) #检查文件是否有第二个标签页，我的文件表08在第二个标签页，按实际修改 if len(xls.sheet_names) &gt; 1: #读取第二个标签页（索引为1），并指定使用第三行作为列名 df = pd.read_excel(xls, sheet_name=1, header=2) #将数据添加到all_data中 all_data.append(df) #使用pd.concat合并所有的数据 all_data = pd.concat(all_data, ignore_index=True) #按照项目名称和项目特征描述分组，然后对工程量进行求和 all_data[&#39;工程量&#39;] = all_data.groupby([&#39;项目名称&#39;, &#39;项目特征描述&#39;])[&#39;工程量&#39;].transform(&#39;sum&#39;) #删除重复的行 all_data = all_data.drop_duplicates([&#39;项目名称&#39;, &#39;项目特征描述&#39;]) #将结果保存到D:\fsx\python\data\xt\合并.xlsx文件中 all_data.to_excel(&#39;D:\\fsx\\python\\data\\xt\\合并.xlsx&#39;, index=False) 完美，本来一天的工作，剩下7.5小时可以摸鱼了！
  ]]></content></entry><entry><title>Helloworld</title><url>/post/20230801-helloworld/</url><categories><category>hugo部署</category></categories><tags><tag>hugo</tag></tags><content type="html"> 你好，世界！</content></entry><entry><title>关于fsx.design</title><url>/about.html</url><categories/><tags/><content type="html"> Hi，我是冯思昕，这是我的个人blog。比较懒，想起来就写一下^_^
愿景
40岁退休过上养老生活。</content></entry></search>
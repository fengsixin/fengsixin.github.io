<?xml version="1.0" encoding="utf-8" standalone="yes"?><search><entry><title>Trae体验日记：初步使用</title><url>/post/20250227-note/</url><categories><category>Trae</category></categories><tags><tag>Trae</tag><tag>AI</tag></tags><content type="html"><![CDATA[   环境说明: MacOS Voyager 14.2 / 32GB+效能模式 重度使用时长: 48小时
🎮 人机交互实录智能补全的魔法时刻在编写Vue组件时，刚键入 const mess，IDE就弹出建议：
1 2 3 const messages = ref&amp;lt;ChatMessage[]&amp;gt;([]) // 并自动带出了我前两天项目里自定义的ChatMessage类型！ &amp;lt;/code&amp;gt;&amp;lt;/pre&amp;gt;&amp;lt;/pre&amp;gt; 这种跨越项目的类型关联能力，细节处见真章。
暗黑模式的冷暖碰撞深夜调试时突然弹出的暗色主题开关着实暖心，但监测到亮度传感器数值低于30%时自动弹出的暗色模式建议弹窗——即便它的渐变动画确实优雅——多少有些让人从编码思维中抽离的割裂感。
快捷键的冰火两重天⌘+U呼出侧边栏的交互行云流水，但发现按 ⌘+Shift+↑组合键试图同时展开三个光标时的延迟卡顿，让我不得不多次调整触摸板压感强度设置。
📊 效能观察台内存占用惊人当同时开启：
浏览器Webview预览 AI代码生成面板 终端实时构建进程 16GB内存瞬间飙升至89%，这与官方宣称的&amp;quot;极简资源占用&amp;quot;形成微妙反差。好在内存交换机制比较智能，未出现明显卡顿。 上下文索引的黑洞试图通过 #app/src/styles/global.css引用全局样式文件时，AI竟准确识别到我在52行定义的 @layer components部分，这种精准的语法树索引让人惊艳。但构建全项目索引耗时20分钟（项目含2.3万行代码），期间CPU温度全程保持82℃以上。
🌈 开发流革新体验超越预期的三板斧AI重构魔法 ：选中旧组件代码选&amp;quot;智能拆分&amp;quot;，自动生成composition-api版本 截图纠错 ：将浏览器控制台报错截图拖入输入框，AI自动定位到未处理的CORS配置 变量重命名链式反应 ：修改 messageList为 chatHistory时，连带prompt里的变量说明一并更新 令人挠心的三处反直觉代码折叠逻辑 ：JSX标签自动折叠的特性，导致初次审查AI生成代码时遗漏错误 终端权限陷进 ：自动执行的 rm -rf node_modules操作没有任何二次确认 中文分词之殇 ：在拼音输入状态下敲击代码补全键会随机触发false …  ]]></content></entry><entry><title>尝试在hugo中引入echart（2）</title><url>/post/20250226-note/</url><categories><category>hugo</category><category>echarts</category></categories><tags><tag>hugo</tag><tag>echart</tag></tags><content type="html">  用AI帮我遍历了整个项目，帮我添加了echart支持，然后修改了md博文引入表格的格式，成功了。。。不得不说AI真是厉害。。。
O(∩_∩)O哈哈~
使用LoveIt主题提供的echarts shortcode来创建图表，非常方便！
  </content></entry><entry><title>又是投标加班的一天</title><url>/post/20230810-note/</url><categories><category>日记</category></categories><tags><tag>加班</tag><tag><no value=/></tags><content type="html">  每年的暑期可真是招投标旺季。。。闲了大半年了，这七月底到八月初已经投了三四个标了。。。
不说了，还得盖章去，不知道晚上几点才能吃饭~~~
今天用chatgpt给小仙女写了两天的信，感觉提示词不怎么变化的话，chatgpt生成的内容重复度好高。。。提示词变换太多了感觉和我自己写一封也差不多了嘛~反正chatgpt感觉生成内容的能力还是不太理想~~~
  </content></entry><entry><title>全光网的那些事儿(2)</title><url>/post/20230809-pol/</url><categories><category>POL</category></categories><tags><tag>PON</tag></tags><content type="html">  目前广泛使用的PON技术在现有的网络包括两种主流技术：EPON和GPON:
图1 XG-PON网络结构示意图GPON最早由**FSAN**组织于2002年9月提出，**ITU-T**在此基础上于2003年1月正式通过了GPON标准系列中的两个标准G.984.1和G.984.2。从2004年开始，ITU又相继批准并颁布了G.984.3和G.984.4，最终形成了G.984.x标准族。目前该系列建议书共有G.984.1~G.984.7等7部分组成。EPON技术由IEEE 802.3 EFM工作组进行标准化。2004年6月，IEEE802.3EFM工作组发布了EPON标准——IEEE802.3ah （2005年并入IEEE802.3-2005标准）。在该标准中将以太网和PON技术结合，在物理层采用PON技术，在数据链路层使用以太网协议，利用PON的拓扑结构实现以太网接入。
可以看到GPON与EPON均在2004年前后制定完成，但因为EPON标准仅在物理层及数据链路层与以太网有所区别，所以EPON设备芯片可以大量复用以太网技术芯片设计。这也导致了EPON设备芯片更早的ASIC（专用集成芯片）化，成本大大低于同时期GPON设备（2004-2008年）。同期日本、美国运营商大量使用EPON技术组网建设。这一时期，EPON被电信引入国内开始规模建设，并一直延续至今。
这一时期，GPON芯片不断成熟，设备价格不断下降至2009年左右已经开始在规模建设中整体性价比超过EPON设备。因为成本的快速下降GPON的标准优势开始慢慢被放大，而EPON的劣势也慢慢显示出来：比如EPON（1.24G）下行带宽仅有GPON（2.5G）的一半、EPON的分光比（1:32）也仅有GPON（1:64）标准的一半、EPON协议传输效率（72%）低于GPON协议传输效率（92%）、EPON不同厂家设备无法互通（EPON协议自由度非常高，各厂家各自对协议进行完善导致）等等。故09年以后商用市场上GPON开始变成主流。
10G EPON的标准制定（IEEE 802.3av）从2006年开始，2009年9月正式颁布标准。IEEE 802.3av确定了两种物理层模式，一种是非对称模式，即10G速率下行和1G速率上行；另外一种是对称模式，即上下行速率均为10G。
IEEE先打了个样，ITU-T/FSAN自然不敢怠 …  </content></entry><entry><title>全光网的那些事儿(1)</title><url>/post/20230808-pol/</url><categories><category>POL</category></categories><tags><tag>PON</tag></tags><content type="html">   PON(Passive Optical Network)无源光纤网络，是目前接入网的主流解决方案。市场上主要存在EPON，10GEPON，GPON，XG-PON，XGS-PON等标准的PON网络可供选择。
目前在运营商市场，EPON、10GEPON标准主要被电信、联通选用。移动则选择GPON、XG-PON技术方案；在日常商用市场上，则是GPON、XG-PON技术方案占据主流。很少见到EPON设备。
PON网络由三部分组成、分别是光线路终端OLT（Optical Line Terminal）、ODN光分配网（Optical Distribution Network）,光网络单元 ONU（ Optical Network Unit）。
图1 XG-PON网络结构示意图XG-PON是基于ITU-T G.987的无源光网络接入技术，是由ITU-T G.984（GPON）标准演进而来。而不同PON标准技术区别如下图：图2 PON标准差异图好了，本篇结束。  </content></entry><entry><title>从合并表获取价格填入广联达表08分表内</title><url>/post/20230807-python/</url><categories><category>python</category></categories><tags><tag>python</tag><tag>便捷工具</tag><tag>广联达</tag></tags><content type="html"><![CDATA[  上一篇把所有广联达表08的分表内容汇总了，然后我挨个填入型号价格以后面临一个巨大问题就是我该怎么填回去。我知道excel有自带的VLOOKUP，但是这么多分表挨个填也使一件十分巨大的工程量。算了，还是问问chaiGPT把。果然又给了我一段代码：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 import os import pandas as pd # 读取合并后的文件 merge_file_path = &#39;D:\\fsx\\python\\data\\hebing.xlsx&#39; merge_df = pd.read_excel(merge_file_path, sheet_name=0, header=0) # 遍历D:\fsx\python\data\xt文件夹下的所有子文件夹 root_folder = &#39;D:\\fsx\\python\\data\\xt&#39; for root, dirs, files in os.walk(root_folder): for file in files: # 只处理Excel文件，并且跳过以~$开头的临时文件和合并后的文件 if file.endswith(&#39;.xlsx&#39;) and not file.startswith(&#39;~$&#39;) and os.path.join(root, file) != merge_file_path: # 读取Excel文件 xls = pd.ExcelFile(os.path.join(root, file), engine=&#39;openpyxl&#39;) # 检查文件是否有第二个标签页 if len(xls.sheet_names) &gt; 1: # 读取第二个标签页（索引为1），并指定使用第三行作为列名 df = pd.read_excel(xls, sheet_name=1, header=2) # 将金额列名改为&#39;金额&#39; df.rename(columns={df.columns[7]: &#39;金额&#39;}, inplace=True) # 将合并后的文件与当前文件进行匹配，对应项目名称和项目特征描述相同的物品，将金额信息填回当前文件内 for index, row in merge_df.iterrows(): df.loc[(df[&#39;项目名称&#39;]==row[&#39;项目名称&#39;]) &amp; (df[&#39;项目特征描述&#39;]==row[&#39;项目特征描述&#39;]), &#39;金额&#39;] = row[&#39;金额&#39;] # 将修改后的数据写回当前文件 writer = pd.ExcelWriter(os.path.join(root, file)) df.to_excel(writer, sheet_name=&#39;Sheet2&#39;, index=False) writer._save() 虽然，但是，价格是全部填进去了，但是貌似excel的文件格式都没有了。。。算了总比我自己填要快，源表格复制一份，然后将价格那一列链接到新文件中，over。今天这个费时间点，应该用了2个小时@！@
  ]]></content></entry><entry><title>合并广联达导出表08的python代码</title><url>/post/20230804-python/</url><categories><category>python</category></categories><tags><tag>便捷工具</tag><tag>python</tag></tags><content type="html"><![CDATA[  接到一个项目投标，招标人发出来的表格是广联达导出的excel表格。我一看，好家伙先分四个区域，然后每个区域又有无数个厂房，厂房文件夹下面才有这个区域的广联达表格。
现在我的任务是需要对这些表格内的产品报价。挨个打开填固然是一种办法，但是很容易发生不同表格内的设备价格不一致问题。最好的办法就是先把表格合并，同一种设备的数量累加然后在总表中填写价格，这样就能避免价格不一致问题。
下面是代码，我使用chatgpt生成的，其实不需要懂编程，自己需要干啥告诉它就好：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 import pandas as pd import os # 初始化一个空的DataFrame来存储所有的数据 all_data = [] #遍历D:\..\python\data\xt文件夹下的所有子文件夹，改成你的文件地址 for root, dirs, files in os.walk(&#39;D:\\fsx\\python\\data\\xt&#39;): for file in files: #只处理Excel文件，并且跳过以~$开头的临时文件 if (file.endswith(&#39;.xlsx&#39;) or file.endswith(&#39;.xls&#39;)) and not file.startswith(&#39;~$&#39;): # 读取Excel文件 xls = pd.ExcelFile(os.path.join(root, file)) #检查文件是否有第二个标签页，我的文件表08在第二个标签页，按实际修改 if len(xls.sheet_names) &gt; 1: #读取第二个标签页（索引为1），并指定使用第三行作为列名 df = pd.read_excel(xls, sheet_name=1, header=2) #将数据添加到all_data中 all_data.append(df) #使用pd.concat合并所有的数据 all_data = pd.concat(all_data, ignore_index=True) #按照项目名称和项目特征描述分组，然后对工程量进行求和 all_data[&#39;工程量&#39;] = all_data.groupby([&#39;项目名称&#39;, &#39;项目特征描述&#39;])[&#39;工程量&#39;].transform(&#39;sum&#39;) #删除重复的行 all_data = all_data.drop_duplicates([&#39;项目名称&#39;, &#39;项目特征描述&#39;]) #将结果保存到D:\fsx\python\data\xt\合并.xlsx文件中 all_data.to_excel(&#39;D:\\fsx\\python\\data\\xt\\合并.xlsx&#39;, index=False) 完美，本来一天的工作，剩下7.5小时可以摸鱼了！
  ]]></content></entry><entry><title>Helloworld</title><url>/post/20230801-helloworld/</url><categories><category>hugo部署</category></categories><tags><tag>hugo</tag></tags><content type="html">  你好，世界！
  </content></entry><entry><title>关于fsx.design</title><url>/about.html</url><categories/><tags/><content type="html">  Hi，我是冯思昕，这是我的个人blog。比较懒，想起来就写一下^_^
愿景40岁退休过上养老生活。
  </content></entry></search>